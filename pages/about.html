<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/prism.css">
	<link rel="apple-touch-icon" sizes="180x180" href="../imgs/favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../imgs/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../imgs/favicon/favicon-16x16.png">
	<link rel="manifest" href="../manifest.json">
	<script src="../js/navigation.js"></script>
	<script src="../js/app.js"></script>
	<title> Tic Tac Toe </title>
</head>

<body>
	<script src="../js/prism.js"></script>
	<div class="container">
		<div>
			<ul class="topnav">
				<li><a href="../index.html" class="logo">VR</a></li>
				<li id="home"><a href="../index.html">Início</a></li>
				<li id="contact"><a href="./contact.html">Contato</a></li>
				<li id="about">
					<a href="./about.html">Sobre</a>
				</li>
			</ul>
		</div>

		<div class="content-wrap" style="text-align: justify; padding: 10px;">
			<h1 style="text-align: center;">Tic tac Toe, jogo da velha ou jogo do galgo</h1>
			<p class="text">
				Em teoria da decisão, o minimax (ou minmax) é um método para minimizar a possível perda máxima. Pode ser
				considerado como a maximização do ganho mínimo (maximin). Começa-se com dois jogadores 0-0 da teoria dos
				jogos, cobrindo ambos os casos em que os jogadores tomam caminhos alternados (por rodadas) ou
				simultaneamente. Pode-se estender o conceito para jogos mais complexos e para tomada de decisão na
				presença de incertezas. Nesse caso, não existe outro jogador, as consequências das decisões dependem de
				fatores desconhecidos.</p>
			<h3>Jogo da velha</h3>
			<p class="text">
				Uma versão simples do algoritmo minimax lida com jogos como o jogo da velha, no qual cada jogador pode
				ganhar, perder ou empatar. Se o jogador A pode vencer com um movimento, esse é o seu melhor movimento.
				Se o
				jogador B identifica que um movimento levará a uma situação em que o adversário pode ganhar no próximo
				movimento, e que existe outro movimento que poderá levar a uma situação em que o adversário pode, no
				máximo,
				empatar, então, este último é o melhor movimento para ele. Após algumas rodadas, é fácil identificar
				qual é
				o melhor movimento. O algoritmo minimax ajuda a encontrar a melhor jogada, ao se caminhar pelas opções
				válidas, a partir do fim do jogo. A cada passo, assume-se que o jogador maximizador está tentando
				maximizar
				as suas chances de ganhar, enquanto na próxima rodada o jogador minimizador está tentando minimizar as
				chances de isso acontecer (maximizando as chances de que ele próprio ganhe). O maximizador precisa
				escolher
				uma jogada que tem a maior dentre as menores pontuações que o minimizador pode fazer aquele ter.</p>
			<h3>Desempenho e otimizações</h3>
			<p class="text">
				O algorítimo mimimax no Jogo da Velha(ou em outros tipos de jogos) pode fazer muito processamento, o que
				pode fazer o algorítimo ser lento, por isso, deve ser importante fazer-se otimizações para que ele seja
				efetuado de forma rápida durante a execução do jogo. Para isso pode ser usado por exemplo a Poda
				alfa-beta.
				Também pode ser importante, principalmente em dispositivos com baixo poder de processamento como
				celulares,
				ou até em dispositivos mais potentes, que os códigos sejam otimizados para evitar-se gastos com
				processamento e tempo desnecessários pois como esse algoritmo faz muito processamento, principalmente
				nas
				análises das primeiras partidas, tais gastos podem ser muito aumentados e causarem um grande impacto na
				queda de desempenho.
			</p>
			<h3>Algoritmo</h3>
			<p class="text">
				O algoritmo minimax com limite de profundidade (usando uma heurística para terminar o vasculhamento após
				uma
				dada profundidade) é mostrado abaixo, em pseudocódigo.
			</p>
			<div style="max-width: 100%;">
				<pre style="overflow: scroll;"><code class="language-wiki">ROTINA minimax(nó, profundidade, maximizador)
						SE nó é um nó terminal OU profundidade = 0 ENTÃO
							RETORNE o valor da heurística do nó
						SENÃO SE maximizador é FALSE ENTÃO
							α ← +∞
							PARA CADA filho DE nó
								α ← min(α, minimax(filho, profundidade-1,true))
							FIM PARA
							RETORNE α
						SENÃO
							//Maximizador
							α ← -∞
							//Escolher a maior dentre as perdas causadas pelo minimizador
							PARA CADA filho DE nó
								α ← max(α, minimax(filho, profundidade-1,false))
							FIM PARA
							RETORNE α
						FIM SE
					FIM ROTINA</code></pre>
			</div>
			<br><br>
			<div style="width: auto; height: auto;">
				<img src="../imgs/diagram.png" alt="Minimax" style="max-width:100%;
	max-height:100%;">
			</div>
			<br><br><br>
			</p>
		</div>

		<div>
			<footer>
				<p>Autor: Vivaldo Roque<br>
				</p>
			</footer>
		</div>
	</div>

</body>

</html>